# 算法思路
## 1. 问题1算法思路
问题1主要考虑哪些点可以共用内存，简单理解一下其实就可以发现只有不存在拓扑关系的点是可以共用内存的，仔细思考我认为这个问题和最大独立集问题有点关系。
首先考虑一个简单版本，即所有节点占用内存的长度都是1B，那么我们可以在原图上做一些变换，把所有存在拓扑关系的点全部连边，那么能合并的点即没有直接连边的点，也即一个独立集，那么问题就转化为了把图分为最少的独立集，考虑到这个问题和最大独立集的关联，因此我们可以不考虑最优解，而去尝试近似解。
对于两个点之间存在的拓扑关系，我分为三类，一类是不存在拓扑关系，记为0类，一类是存在不严格的拓扑关系（即经过上游A不一定经过下游B，经过下游B不一定经过上游A），记为1类，一类是存在严格的拓扑关系（即经过上游A一定会经过下游B，并且不存在其他路径经过下游B），记为2类，为了找出这三种关系我设计了一种哈希算法，从一个超级源点开始和每个点都相连，起初流量为1，遇到分支则进行复制，例如分为三个下游节点，则总流量变为3，只有下游节点完全接收全部流量，并且在反图中上游节点完全接收下游节点流量时才能判定为2类节点，而0和1类节点判定相对容易。
然后就是分配过程，这个过程采取了贪心的算法，如果之前有节点可以进行共用，则共用内存，否则自己新开一个组，可以发现节点的排序对结果有很大影响，这里采用按长度排序和按节点度排序（时间原因未实现）。
## 2. 问题2算法思路
问题2主要考虑哪些节点可以共用条目以及合并条目，不难发现
(1) 共用条目：只有不存在拓扑关系并且共用长度相同的内存的节点可以共用条目
(2) 合并条目：只有一个下游节点和条目内所有节点都存在2类拓扑关系才可以合并条目
(3) 相邻原则：只有条目内存在一个相邻节点才可以进行合并条目的操作
因此我们采取贪心的方式去实现：
在拓扑排序的过程中，**倒序**遍历分组，检查每一个分组能否合并，如果合并则插入，否则并不立即删除其相邻节点的入度，而是等所有度0节点都检查是否能插入，然后这些度0节点为不可合并的节点，剩下的度0节点不存在拓扑关系，此时分组生成共用条目以减少条目数量。
代码中实现了共用条目，因时间原因没有实现合并条目。
